Operating-System Services
-------------------------
- OS provides an environment for executing programs and offers useful services
  for users and efficient system management.

User-Focused Services
---------------------
- User Interface (UI):
  * GUI → windows, mouse, keyboard
  * Touchscreen → mobile devices
  * CLI → text commands
- Program Execution:
  * Load, run, and terminate programs (normal or error).
- I/O Operations:
  * OS provides safe, efficient access to files and devices.
- File-System Manipulation:
  * Read/write, create/delete, search files/directories.
  * Manage permissions and access control.
- Communications:
  * Exchange info between processes (same system or over network).
  * Methods → Shared Memory or Message Passing.
- Error Detection:
  * Detect/correct errors in hardware, I/O, or user programs.
  * Take action: halt system, terminate process, or return error codes.

System-Focused Services
-----------------------
- Resource Allocation:
  * Manage CPU, memory, storage, I/O devices among processes.
  * Use scheduling and allocation routines for efficiency.
- Logging / Accounting:
  * Track usage of programs and resources.
  * Used for billing or performance statistics.
- Protection and Security:
  * Prevent unauthorized access to processes and resources.
  * Authentication (passwords, etc.).
  * Defend system from internal and external threats.



User and Operating-System Interface
-----------------------------------
- Users interact with the OS via:
  * Command-Line Interface (CLI)
  * Graphical User Interface (GUI)

Command Interpreters (Shells)
-----------------------------
- Special program that runs when user logs in or starts a process.
- Examples (UNIX/Linux): Bourne-Again shell (bash), C shell, Korn shell.
- Choice of shell = user preference.

Main Function
-------------
- Read and execute user commands.
- Common tasks: create, delete, copy, list, execute files.

Implementation Approaches
-------------------------
1. Built-in Commands:
   * Interpreter contains code to directly execute commands.
   * Interpreter size grows with number of commands.

2. System Programs (UNIX style):
   * Interpreter invokes external program files (e.g., `rm file.txt` → runs program `rm`).
   * Easy to add new commands by creating new programs.
   * Interpreter remains small and flexible.


Graphical User Interface (GUI)
------------------------------
- User interacts with OS via windows, menus, icons (desktop metaphor).
- Mouse used to point, click, select, or open programs/files/folders.
- Origin:
  * First GUI → Xerox Alto (1973, Xerox PARC).
  * Popularized by Apple Macintosh (1980s).
  * Microsoft Windows (since 1.0) built on GUI over MS-DOS.
- Evolution:
  * macOS → Aqua interface.
  * Windows → enhanced appearance and functionality over versions.
- UNIX/Linux:
  * Traditionally CLI-based.
  * GUIs available → KDE, GNOME (open-source desktops).

Touch-Screen Interface
----------------------
- Common in mobile devices (smartphones, tablets).
- User interacts with gestures: tap, press, swipe.
- Replaces physical keyboards with on-screen keyboards.
- Examples:
  * iPhone & iPad → Springboard interface.
  * Earlier smartphones used physical keyboards (now mostly obsolete).


Choice of Interface
-------------------
- CLI vs GUI → mostly personal preference.
- Command-Line Interface (CLI):
  * Preferred by system administrators & power users.
  * More efficient for complex or repetitive tasks.
  * Supports scripting (shell scripts) for automation.
  * Common in UNIX/Linux systems.
- Graphical User Interface (GUI):
  * Preferred by most Windows and macOS users.
  * Easier for everyday tasks, visually intuitive.
  * Some functions may only exist in CLI, not GUI.
- Hybrid Examples:
  * Windows → GUI + optional touch screen.
  * macOS → Aqua GUI + CLI (UNIX-based).
- Mobile Systems:
  * Almost entirely touch-based (iOS, Android).
  * CLIs exist but rarely used.
- Key Note:
  * UI design is separate from OS internals.
  * OS focuses on providing services; UI is just one layer above.


System Calls
------------
- Interface between user programs and OS services.
- Usually provided as functions in C/C++; low-level tasks may use assembly.

Example: Copying One File to Another
------------------------------------
1. Acquire file names:
   * CLI: `cp in.txt out.txt`
   * Interactive: prompts + keyboard input
   * GUI: menus, icons, file selection
   → Requires I/O system calls

2. Open files:
   * Open input file → handle errors (file not found, access denied)
   * Create/open output file → handle conflicts (file exists, overwrite, abort, or ask user)

3. Copy loop:
   * Read from input file (system call)
   * Write to output file (system call)
   * Handle errors (EOF, disk errors, no space, device issues)

4. Finish:
   * Close files (system calls)
   * Display completion message (system call)
   * Terminate program normally (system call)

Key Idea
--------
- Even simple tasks (like copying a file) involve **many system calls**:
  * File operations, I/O, error handling, process termination.
- System calls provide controlled, safe access to OS resources.



Application Programming Interface (API)
---------------------------------------
- Provides a set of functions for application programmers to access OS services.
- Hides low-level system-call details from programmers.
- Common APIs:
  * Windows API → Windows systems
  * POSIX API → UNIX, Linux, macOS
  * Java API → Java Virtual Machine

How API Works
-------------
- Programmer calls API function (e.g., read(), CreateProcess()).
- API function invokes the appropriate system call internally.
- OS executes the system call in kernel mode, returns result to program.
- Programmer only needs to follow API; OS implementation details are hidden.
- Run-Time Environment (RTE) manages API, libraries, loaders, and compilers.

Example: read() in UNIX/Linux
------------------------------
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count)
- Parameters:
  * fd → file descriptor
  * buf → memory buffer
  * count → max bytes to read
- Returns number of bytes read, 0 = EOF, -1 = error.

Parameter Passing Methods
-------------------------
1. Registers → simplest, fast.
2. Memory block/table → used when too many parameters.
3. Stack → push parameters, OS pops them.
- Linux: ≤5 parameters → registers, >5 → block in memory.


Types of System Calls:

Process Control System Calls
----------------------------
- Terminate program:
  * end() → normal termination
  * abort() → abnormal termination (may produce memory dump, error message, log file)
- Error levels indicate severity:
  * 0 → normal termination
  * Higher values → more severe errors
  * Used by command interpreter/programs to decide next actions
- Load and execute other programs:
  * load(), execute() → run another program
  * Control after execution:
    - Return to original program (requires saving memory image)
    - Run concurrently (multiprogramming)
  * create process() → system call to create new process

Process Attributes & Management System Calls
-------------------------------
- get process attributes() / set process attributes() → check/set priority, max execution time, etc.
- terminate process() → stop a created process if unnecessary or incorrect

Waiting & Synchronization System Calls
------------------------
- wait time() → wait for a specified time
- wait event() → wait for a specific event
- signal event() → signal that an event occurred
- acquire lock(), release lock() → lock shared data to ensure integrity when accessed by multiple processes

Examples
--------
1. Arduino (Single-tasking system):
   - Program ("sketch") uploaded via PC to flash memory
   - Bootloader loads sketch
   - Only one sketch runs at a time; new sketch replaces old
   - Input via hardware sensors, no UI

2. FreeBSD (Multitasking system):
   - Shell waits for user commands
   - fork() → create new process
   - exec() → load and execute program
   - Background execution:
     - Shell continues while program runs
     - Input via files or GUI
   - exit() → terminate process, return status code (0 = success, non-zero = error)


File Management System Calls
----------------------------
- Create and delete files:
  * create() → create new file with name and attributes
  * delete() → remove file
- Open and use files:
  * open() → open a file for access
  * read() / write() → read from or write to a file
  * reposition() → move file pointer (rewind, skip to end, etc.)
  * close() → close file when done
- Directory operations:
  * Same operations can apply to directories in a hierarchical file system
- File attributes:
  * get file attributes() → read attributes (name, type, protection, accounting info)
  * set file attributes() → modify attributes
  * Some systems provide move() and copy() or APIs to perform these operations
  * System programs callable by other programs may act as APIs

Device Management System Calls
------------------------------
- Resources (memory, disk drives, files, etc.) may be requested and released
  * request() → request exclusive access to a device
  * release() → release the device after use
- I/O operations:
  * read() / write() / reposition() → similar to file operations
- Some OS merge files and devices into a single file-device structure
  * I/O devices may be identified by special file names, directory placement, or attributes
- Design decisions can make files and devices appear similar to the user, even if system calls differ

Information Maintenance System Calls
------------------------------------
- Transfer info between user program and OS:
  * time() → return current time
  * date() → return current date
  * Other calls → return system info (OS version, free memory/disk space)
- Debugging support:
  * dump() → memory dump for debugging
  * strace (Linux) → list system calls executed
  * Single-step CPU mode → trap after each instruction for debugging
- Time profiling:
  * Records program counter at timer interrupts
  * Generates statistical picture of time spent in program sections
- Process information:
  * get process attributes() / set process attributes() → access or modify process details



Communication System Calls
--------------------------
- Two models of interprocess communication (IPC):
  1. Message-passing model
  2. Shared-memory model

Message-Passing Model:
- Processes exchange messages directly or via a common mailbox
- Connection setup required:
  * get hostid() → translate host name to identifier
  * get processid() → translate process name to identifier
  * open connection() / close connection() → start and end communication
  * accept connection() → recipient permits communication
- Client-server model:
  * Client → source of communication
  * Server → receiving daemon, executes wait for connection()
  * read message() / write message() → exchange data

Shared-Memory Model:
- Processes create and attach to shared memory:
  * shared memory create() → create shared memory region
  * shared memory attach() → access memory region of another process
- Shared memory allows direct reading/writing between processes
- Processes responsible for avoiding conflicts
- Threads (Chapter 4) share memory by default

Comparison:
- Message passing → easier for intercomputer communication, handles small data
- Shared memory → fastest for same-computer communication, requires synchronization and protection

Protection System Calls
-----------------------
- Control access to resources (files, disks, etc.)
- set permission() / get permission() → set or query resource permissions
- allow user() / deny user() → grant or revoke user access
- Protection ensures safe resource access in multiprogramming and networked environments
- Security (external threats) discussed in Chapter 16



System Services
---------------

- Definition:
  * Also called system utilities
  * Provide environment for program development and execution
  * Some are simple interfaces to system calls; others are complex

- Categories of System Services:

1. File Management:
   - Create, delete, copy, rename, print, list files and directories
   - Access and manipulate file content and structure

2. Status Information:
   - Query system for date, time, memory, disk space, number of users
   - Provide performance, logging, debugging info
   - Output may be printed, displayed in GUI, or stored in registry

3. File Modification:
   - Text editors to create/modify file content
   - Commands to search, transform text

4. Programming-Language Support:
   - Compilers, assemblers, debuggers, interpreters (C, C++, Java, Python)
   - Provided with OS or as separate downloads

5. Program Loading and Execution:
   - Loaders: absolute, relocatable, linkage, overlay loaders
   - Debugging systems for high-level or machine language

6. Communications:
   - Enable virtual connections between processes, users, and systems
   - Functions: messaging, web browsing, email, remote login, file transfer

7. Background Services:
   - System programs launched at boot time
   - Some terminate after task; others run continuously (services, subsystems, daemons)
   - Examples: network daemon, process schedulers, error monitoring, print servers
   - OS may run activities in user context via daemons

- Applications:
  * Supplied OS programs for common tasks: web browsers, word processors, spreadsheets, databases, compilers, plotting/statistics, games

- User View:
  * User interacts with system via application and system programs, not direct system calls
  * Same hardware can present multiple interfaces (GUI, shell, dual-boot OS)
  * System calls remain consistent, interfaces differ


Linkers and Loaders
-------------------

- Purpose:
  * Bring program from disk into memory
  * Place program in context of a process to run on CPU

- Steps to Run a Program:
  1. Compilation:
     - Source files (.c, .cpp, etc.) → object files (.o)
     - Relocatable object file → can be loaded at any memory address
  2. Linking:
     - Combines object files into single executable
     - Can include libraries (e.g., standard C/math library using -lm)
     - Relocation performed → final addresses assigned, code/data adjusted
  3. Loading:
     - Loader places executable into memory
     - Program becomes eligible to run on CPU
     - On UNIX: shell uses fork() → creates process, exec() → invokes loader
     - On GUI: double-click icon triggers loader similarly

- Dynamic Linking:
  * Libraries may be dynamically linked during program load
  * Example: DLLs in Windows, conditional loading of math library
  * Benefits: avoids loading unused libraries, multiple processes can share libraries → memory savings

- File Formats:
  * Contain compiled code + symbol table (metadata for functions/variables)
  * UNIX/Linux → ELF (Executable and Linkable Format)
    - Separate formats for relocatable (.o) and executable files
    - Executable files contain entry point → address of first instruction
  * Windows → PE (Portable Executable)
  * macOS → Mach-O

- ELF Utilities:
  * file main.o → reports relocatable ELF object
  * file main → reports ELF executable
  * readelf → examine sections and details of ELF files




Why Applications Are OS Specific
--------------------------------
- User View:
  * Applications compiled on one OS usually cannot run on another OS
  * Running same application on multiple OSs requires:
    1. Interpreted languages (Python, Ruby) – interpreter executes source line by 
    line on native CPU, calls native system calls, limited performance and OS features
    2. Virtual Machine languages (Java) – RTE includes loader, bytecode verifier, VM; 
    allows app to run across OSs with RTE, similar performance limits as interpreters
    3. Standard language/APIs – compiler generates OS- and machine-specific binaries; 
    requires porting and testing for each OS (e.g., POSIX API for UNIX variants)

- System-Level Reasons:
  * Each OS has unique system calls differing in:
    - Numbering, operands, invocation method, behavior, and return values
  * OS provides libraries with APIs (e.g., GUI functions) – apps calling one OS's APIs may fail on another
  * Different binary formats for executables dictate layout of headers, instructions, and variables
  * CPUs have varying instruction sets; binaries must match CPU architecture
  * Application Binary Interface (ABI) specifies low-level binary compatibility per OS and CPU:
    - Address width, parameter passing, stack organization, system library format, data type sizes
  * ELF format in UNIX/Linux standardizes binary layout across UNIX systems but not across CPU architectures
  * Without interpreter, RTE, or OS-specific binary, applications fail on other OSs
  * Cross-platform apps (like Firefox) require separate builds and testing for each OS and CPU




Operating-System Design and Implementation
-------------------------------------------
- User View:
  * OS design depends on hardware type and system type: desktop/laptop, mobile, distributed, real-time
  * Users want convenience, ease of learning, reliability, safety, and speed
  * Developers want system to be easy to design, implement, maintain; also flexible, reliable, error-free, and efficient
  * No unique solution; different requirements yield different OS designs (e.g., VxWorks vs Windows Server)

- Mechanisms and Policies:
  * Mechanism = how something is done; Policy = what is done
  * Separation allows flexibility; policies can change without altering mechanisms
  * Example: Timer mechanism ensures CPU protection; setting timer length is policy
  * Priority mechanism can support multiple policies (I/O vs CPU intensive programs)
  * Microkernel OS: minimal mechanisms, policy implemented via modules or user programs
  * Windows/macOS: mechanism and policy tightly integrated for consistent interface
  * Open-source OS (Linux): mechanism defined, policy can be changed by modifying components (e.g., CPU scheduler)
  * Resource allocation decisions: 'what' → policy; 'how' → mechanism






Implementation of Operating Systems
-----------------------------------
- User View:
  * Once designed, an OS must be implemented as a collection of programs
  * Early OSs: written entirely in assembly language
  * Modern OSs: mostly written in higher-level languages (C, C++, Java), with small assembly portions
  * Example: Android
    - Kernel: mostly C + some assembly
    - System libraries: C or C++
    - Application frameworks: mostly Java

- Advantages of higher-level languages:
  * Faster development, more compact code, easier to understand and debug
  * Compiler improvements benefit entire OS
  * Easier to port to different hardware (embedded devices, x86, ARM)
  * Modern compilers produce optimized code, sometimes better than hand-written assembly for large programs

- Disadvantages:
  * Slightly reduced speed and increased storage needs (minor on modern systems)

- Performance considerations:
  * Major improvements come from better algorithms and data structures, not assembly coding
  * Only a small part of OS is performance-critical: interrupt handlers, I/O manager, memory manager, CPU scheduler
  * Critical routines can be optimized after system works correctly



Monolithic Structure
-------------------
- User View:
  * OS functionality combined into a single, static binary running in one address space
  * Simplest OS organization, minimal internal structure
  * Example: Original UNIX
    - Two main parts: kernel and system programs
    - Kernel provides file system, CPU scheduling, memory management, device drivers
    - Layered approach: everything below system-call interface and above hardware is kernel

- Linux Example:
  * Based on UNIX; monolithic kernel running entirely in kernel mode
  * Applications communicate with kernel via glibc C library and system-call interface
  * Kernel has modular features allowing runtime modification (dynamic modules)

- Advantages:
  * High performance: minimal system-call overhead
  * Fast internal kernel communication

- Disadvantages:
  * Difficult to implement, maintain, and extend
  * All functionality in a single address space increases complexity

- Usage:
  * Still common in UNIX, Linux, and Windows due to efficiency and speed




Layered Approach
----------------
- User View:
  * OS divided into separate layers, each with specific functionality
  * Bottom layer (layer 0) = hardware; top layer (layer N) = user interface
  * Each layer uses only the operations of lower-level layers, hiding internal implementation from higher layers

- Advantages:
  * Simplicity in construction, debugging, and verification
    - Debug one layer at a time; errors must be in the current layer
  * Encapsulation: higher layers don’t need to know details of lower layers
  * Supports modularity and easier system modification

- Implementation Notes:
  * Each layer = data structures + functions invoked by higher layers
  * Each layer invokes operations on lower layers only

- Disadvantages:
  * Difficult to define precise functionality for each layer
  * Performance overhead: user program may traverse multiple layers for services
  * Few OSs use pure layered approach; contemporary systems often have fewer layers with more functionality




Microkernels and Modules
------------------------
- Microkernels:
  * OS structure where only essential services remain in kernel; other services run in user space
  * Typical microkernel services: minimal process management, memory management, communication
  * Client programs and services communicate via message passing through the microkernel
  * Advantages:
    - Easier to extend OS: add new services in user space without changing kernel
    - Smaller kernel → easier to port to different hardware
    - Increased security and reliability: service failure doesn’t crash OS
  * Examples:
    - Darwin (macOS/iOS): uses Mach microkernel
    - QNX Neutrino: real-time OS with microkernel for message passing, process scheduling
  * Disadvantages:
    - Performance overhead from message passing and process switching
    - Example: early Windows NT microkernel slower than Windows 95; later versions moved closer 
      to monolithic for performance


Modules
------------------------

- Modules (Loadable Kernel Modules - LKMs):
  * Kernel has core components; additional services linked via modules at boot or runtime
  * Core services (e.g., CPU scheduling, memory management) in kernel; 
  other services (e.g., file systems, device drivers) loaded dynamically
  * Advantages:
    - Flexible and modular while maintaining performance
    - Modules can communicate without message passing
    - Dynamic loading allows runtime addition/removal (e.g., USB drivers)
  * Examples:
    - Linux, macOS, Solaris, Windows use LKMs
    - Linux LKMs support device drivers and file systems


Hybrid Systems (OS Structures)
------------------------
- Most modern OS = hybrid (monolithic + microkernel mix)
- Goal: balance performance, security, usability
- Linux: monolithic + modular (dynamic kernel modules)
- Windows: monolithic but w/ microkernel traits (subsystems, loadable modules)

# macOS vs iOS
- macOS: desktop/laptop (Intel)
- iOS: mobile (ARM), strict security, restricted APIs
- Shared architecture:
  1. User Experience Layer:
     - macOS: Aqua UI (mouse/trackpad)
     - iOS: Springboard UI (touch)
  2. Application Frameworks:
     - Cocoa (macOS), Cocoa Touch (iOS, mobile hardware support)
  3. Core Frameworks:
     - Graphics/media (QuickTime, OpenGL)
  4. Kernel Environment = Darwin

# Darwin Kernel (Hybrid)
- Combines Mach microkernel + BSD UNIX kernel + I/O Kit + kexts
- Two syscall interfaces:
  - Mach traps (microkernel services)
  - BSD syscalls (POSIX)
- Mach provides: memory mgmt, CPU scheduling, IPC (msg passing, RPC)
- BSD provides: POSIX (e.g., fork())
- I/O Kit: device drivers + dynamic modules
- Runs in one address space → avoids microkernel overhead
- Darwin = open source, but Cocoa/frameworks = proprietary


Android OS (Hybrid System)
------------------------

- Developed by Open Handset Alliance (Google-led)
- Open source, runs on many mobile platforms (vs iOS closed + Apple-only)

# Architecture (Layered stack)
apps
 └─ Android Runtime (ART VM)
 └─ Frameworks + JNI
 └─ Native Libraries (SQLite, SSL, WebKit, OpenGL, Media, etc.)
 └─ Bionic libc
 └─ HAL (Hardware Abstraction Layer)
 └─ Linux Kernel (modified for mobile)

# Key Components
- Apps: written in Java using Android API (not standard Java API)
- ART (Android Runtime):
  - Java → bytecode (.class) → .dex
  - Ahead-of-Time (AOT) compilation → native code at install
  - Benefits: faster execution, lower power consumption (better for mobile)
- JNI: lets Java access hardware directly (not portable across devices)
- Native libraries: support browser (WebKit), DB (SQLite), networking (SSL), graphics (OpenGL), etc.
- HAL: abstracts hardware (camera, GPS, sensors) → consistent interface across devices
- Bionic libc: smaller + faster than GNU glibc, avoids GPL, optimized for low CPU/memory
- Linux kernel: modified for mobile (power mgmt, memory, IPC → Binder)

# KEY IDEA:
Android = layered hybrid system built on Linux kernel, 
uses ART VM for efficient Java execution, HAL for hardware portability, 
and Bionic libc for lightweight performance on mobile.





Windows Subsystem for Linux (WSL) - Hybrid Architecture
------------------------

- Windows uses hybrid design: user-mode subsystems + kernel
- Subsystems emulate other OS environments (e.g., Linux)
- WSL (Windows 10+): run native Linux ELF binaries on Windows

# Typical Workflow
1. User launches bash.exe → bash shell
2. WSL creates a Linux instance:
   - init process → starts /bin/bash
3. Each process runs inside a Windows Pico process:
   - Loads Linux binary into its address space
   - Provides execution environment for Linux app

# System Call Handling
- Pico processes communicate with kernel services:
  - **LXCore** and **LXSS**
- Linux system calls:
  - If exact Windows equivalent exists → LXSS forwards call
  - If partial equivalent → LXSS performs partial work + calls Windows syscall
  - If no equivalent → LXSS implements functionality in software
- Example: Linux fork() → LXSS + Windows CreateProcess()


Operating-System Generation & Booting
-------------------------------------

# OS Generation Overview
- OS can target:
  - Specific machine (embedded)
  - Class of machines (desktop/laptop/mobile)
- Most computers come with preinstalled OS (Windows/macOS)
- Replacing/adding OS steps:
  1. Write/obtain source code
  2. Configure OS for hardware
  3. Compile OS
  4. Install OS
  5. Boot system

# Configuration Approaches
1. Tailored Build:
   - Modify source + full compile → highly specific OS
2. Precompiled Modules:
   - Select/link needed modules → faster, general OS
3. Modular/Runtime Selection:
   - Parameters set for execution-time selection → flexible

# Differences:
- Size & generality
- Ease of hardware adaptation
- Embedded → tailored build
- Modern desktop/mobile → precompiled + loadable kernel modules




System Boot
-----------

# Boot Overview
- Booting = starting computer by loading kernel
- Steps:
  1. Bootstrap program / boot loader locates kernel
  2. Kernel loaded into memory & started
  3. Kernel initializes hardware
  4. Root file system mounted

# Boot Process
- BIOS-based (multistage):
  - BIOS runs initial boot loader from firmware
  - Loads second boot loader from boot block
  - Boot block loader loads OS or next stage
- UEFI (modern PCs):
  - Replaces BIOS
  - Supports 64-bit systems & larger disks
  - Single complete boot manager → faster boot

# Bootstrap Tasks
- Load kernel into memory
- Run diagnostics (CPU, memory, devices)
- Initialize CPU registers, device controllers, memory
- Mount root file system → system runs

# Linux Boot
- GRUB = open-source boot loader
  - Config file sets boot parameters (kernel image, root FS)
  - Flexible: select kernels, modify kernel parameters at boot
- Kernel image compressed → extracted after loading
- initramfs (temporary RAM FS) contains drivers/modules
  - After drivers loaded → switch to real root FS
- Systemd process started → other services → login prompt

# Mobile Boot (Android)
- Uses LK (Little Kernel) boot loader (no GRUB)
- Kernel image compressed, initramfs used as root FS
- init process started → services launched → home screen displayed

# Recovery / Diagnostic Modes
- Most OS (Windows, Linux, macOS, iOS, Android) boot loaders:
  - Recovery mode / single-user mode
  - Fix hardware issues, repair FS, reinstall OS




Operating-System Debugging
--------------------------

# Debugging Overview
- Debugging = finding & fixing errors in hardware & software
- Includes performance tuning (removing bottlenecks)
- Covers process failures, kernel crashes, and performance monitoring

# Failure Analysis
- Process failure -> error info logged; core dump (process memory snapshot) saved
- Debuggers probe running programs & core dumps
- Kernel failure = crash
  - Saves error info & memory state to crash dump
  - Often writes memory to a reserved disk area (outside any file system); after reboot a process copies that area into a crash-dump file for analysis
- User-level debugging vs. kernel debugging: different tools & techniques; kernel debugging is more complex

# Performance Monitoring & Tuning
- Goal = improve performance by finding & removing bottlenecks
- Monitoring modes: per-process or system-wide
- Two approaches: counters and tracing

# Counters (examples)
- Per-process: ps, top
- System-wide: vmstat, netstat, iostat
- Linux: /proc pseudo-filesystem holds kernel and per-process stats (/proc/<pid>)
- Windows: Task Manager provides processes, CPU, memory, networking stats

# Tracing (examples)
- Per-process tracing: strace, gdb (source-level debugging)
- System-wide tracing: perf, tcpdump
- Tracing records events (e.g., system-call sequences) rather than sampling counters

# Tools & Notes
- Counter tools read current metric values; tracing tools record detailed event data
- New kernel-enabled analysis tools (e.g., BCC) improve dynamic kernel tracing and observability

# Kernighan's Law (quote & implication)
- "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."
- Implication: favor clear/simple code — it's easier to understand, maintain, and debug



# BCC (BPF Compiler Collection) 
- Debugs user-level & kernel interactions with minimal impact
- Front-end to eBPF (extended Berkeley Packet Filter)
  - Programs written in subset of C → compiled to eBPF instructions → inserted into running Linux kernel
  - Verifier ensures safe execution (performance & security)
- BCC simplifies eBPF via Python tools embedding C code
- Tools inserted via probes or tracepoints

## Usage Examples
- `disksnoop.py` → traces disk I/O
TIME(s) T BYTES LAT(ms)
1946.29186700 R 8 0.27
1946.33965000 R 8 0.26
1948.34585000 W 8192 0.96
1950.43251000 R 4096 0.56
1951.74121000 R 4096 0.35

pgsql
Copy code
- Shows timestamp, Read/Write, bytes, latency in ms
- `opensnoop -p 1225` → traces open() calls for process ID 1225

# Key Points
- Safe to use on live production systems
- Useful for performance bottlenecks & security monitoring
- Can trace MySQL, Java, Python, and process-specific activity
- BCC is actively evolving with new features constantly added




Summary
-------

- An operating system provides an environment for executing programs by offering services to users and programs.

- Three primary approaches for interacting with an OS:
  1. Command interpreters
  2. Graphical user interfaces (GUI)
  3. Touchscreen interfaces

- System calls provide access to OS services; programmers use system call APIs.

- System calls categories:
  1. Process control
  2. File management
  3. Device management
  4. Information maintenance
  5. Communications
  6. Protection

- Standard C library provides system-call interface for UNIX/Linux.

- OS includes system programs providing utilities to users.

- Linker: combines multiple relocatable object modules → single executable.
- Loader: loads executable into memory for CPU execution.

- OS-specific applications arise from:
  - Different binary formats
  - Different CPU instruction sets
  - Varying system calls

- OS design goals determine policies, implemented via mechanisms.

- Monolithic OS:
  - Single, static binary
  - Runs in single address space
  - Efficient but hard to modify

- Layered OS:
  - Discrete layers (hardware → user interface)
  - Easier structure, but performance may suffer

- Microkernel OS:
  - Minimal kernel
  - Services as user-level applications
  - Communication via message passing

- Modular OS:
  - Services provided through modules loaded/unloaded at runtime
  - Many modern OS use hybrid of monolithic kernel + modules

- Boot loader:
  - Loads OS into memory
  - Performs initialization
  - Starts system execution

- Performance monitoring:
  - Counters → system-wide or per-process statistics
  - Tracing → follows program execution through OS


Practice Exercises
------------------


2.1 What is the purpose of system calls?
System calls are interfaces provided by the OS that allow user programs to request services from the kernel, 
such as file operations, process control, memory management, etc.


2.2 What is the purpose of the command interpreter? Why is it usually
separate from the kernel?

A command interpreter (shell) is a program that reads user commands and executes them, 
either directly or by calling other programs.

It is usually separate from the kernel because:
It is part of the user-level software, not core OS functionality.
Keeping it separate reduces kernel complexity and increases flexibility.


2.3 What system calls have to be executed by a command interpreter or shell
in order to start a new process on a UNIX system?

fork() → exec() → wait()


2.4 What is the purpose of system programs?

Programs that are provided by the operating system to perform common tasks and support user interaction, 
but they run in user space, not in the kernel.

Purpose:
1 - Provide a convenient environment for users to perform tasks (like file manipulation, 
program compilation, text editing).
2 - Support system operation without requiring users to interact directly with the kernel.
3 - Bridge between user and OS: They make it easier to access OS services.

2.5 What is the main advantage of the layered approach to system design?

1 - Modularity: Each layer performs a specific function, so the system is easier to understand, develop, and maintain.
2 - Simplified debugging and testing: You can test one layer at a time without worrying about the whole system.
3 - Improved reliability: Errors in one layer are less likely to affect others.

What are the disadvantages of the layered approach?

1 - performance overhead
2 - Reduced flexibility
3 - Difficulty in defining layers

2.6 List five services provided by an operating system, and explain how each
creates convenience for users. In which cases would it be impossible for
user-level programs to provide these services? Explain your answer.

Read – read data from a file or device.
Write – write data to a file or device.
Open – open a file or device for use.
Close – close a file or device when done.
Create – create a new file or directory.
Delete/Remove – delete a file or directory.
Execute – start running a program.
Fork – create a new process.
Wait – wait for a process to finish.

The OS provides convenience, safety, and abstraction.
User-level programs could theoretically replicate some services, but it would require complex, low-level code, 
would be error-prone, and would lack proper protection and efficiency.


2.7 Why do some systems store the operating system in firmware, while
others store it on disk?

Storing the OS in firmware is because firmware ensures the OS is always available immediately, 
especially when there is no disk.

Storing it on disk allows larger, updateable OS but requires bootstrapping 
from firmware (like BIOS or UEFI) to load the OS.


2.8 How could a system be designed to allow a choice of operating systems
from which to boot? What would the bootstrap program need to do?

Hardware/BIOS/UEFI support:

The firmware (BIOS or UEFI) should allow the user to choose which OS to boot at startup.
This can be done with a boot menu.
Bootstrap program (bootloader) role:
After the user selects an OS, the bootloader locates the OS kernel on the disk or storage.
It then loads the OS into memory and transfers control to it.

Power on → BIOS/UEFI → User chooses OS → Bootloader loads selected OS → OS starts


Chapter 2 Exercises
2.9 The services and functions provided by an operating system can be
divided into two main categories. Briefly describe the two categories,
and discuss how they differ.



2.10 Describe three general methods for passing parameters to the operating
system.



2.11 Describe how you could obtain a statistical profile of the amount of time
a program spends executing different sections of its code. Discuss the
importance of obtaining such a statistical profile.



2.12 What are the advantages and disadvantages of using the same systemcall interface 
for manipulating both files and devices?



2.13 Would it be possible for the user to develop a new command interpreter
using the system-call interface provided by the operating system?



2.14 Describe why Android uses ahead-of-time (AOT) rather than just-in-time
(JIT) compilation.



2.15 What are the two models of interprocess communication? What are the
strengths and weaknesses of the two approaches?


2.16 Contrast and compare an application programming interface (API) and
an application binary interface (ABI).


2.17 Why is the separation of mechanism and policy desirable?


2.18 It is sometimes difficult to achieve a layered approach if two components
of the operating system are dependent on each other. Identify a scenario
in which it is unclear how to layer two system components that require
tight coupling of their functionalities.


2.19 What is the main advantage of the microkernel approach to system
design? How do user programs and system services interact in a microkernel architecture? 
What are the disadvantages of using the microkernel approach?


2.20 What are the advantages of using loadable kernel modules?


2.21 How are iOS and Android similar? How are they different?


2.22 Explain why Java programs running on Android systems do not use the
standard Java API and virtual machine.


2.23 The experimental Synthesis operating system has an assembler incorporated in the kernel. 
To optimize system-call performance, the kernel assembles routines within kernel space to minimize 
the path that the system call must take through the kernel. This approach is the antithesis of
the layered approach, in which the path through the kernel is extended
to make building the operating system easier. Discuss the pros and cons
of the Synthesis approach to kernel design and system-performance optimization.
