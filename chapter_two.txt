Operating-System Services
-------------------------
- OS provides an environment for executing programs and offers useful services
  for users and efficient system management.

User-Focused Services
---------------------
- User Interface (UI):
  * GUI → windows, mouse, keyboard
  * Touchscreen → mobile devices
  * CLI → text commands
- Program Execution:
  * Load, run, and terminate programs (normal or error).
- I/O Operations:
  * OS provides safe, efficient access to files and devices.
- File-System Manipulation:
  * Read/write, create/delete, search files/directories.
  * Manage permissions and access control.
- Communications:
  * Exchange info between processes (same system or over network).
  * Methods → Shared Memory or Message Passing.
- Error Detection:
  * Detect/correct errors in hardware, I/O, or user programs.
  * Take action: halt system, terminate process, or return error codes.

System-Focused Services
-----------------------
- Resource Allocation:
  * Manage CPU, memory, storage, I/O devices among processes.
  * Use scheduling and allocation routines for efficiency.
- Logging / Accounting:
  * Track usage of programs and resources.
  * Used for billing or performance statistics.
- Protection and Security:
  * Prevent unauthorized access to processes and resources.
  * Authentication (passwords, etc.).
  * Defend system from internal and external threats.



User and Operating-System Interface
-----------------------------------
- Users interact with the OS via:
  * Command-Line Interface (CLI)
  * Graphical User Interface (GUI)

Command Interpreters (Shells)
-----------------------------
- Special program that runs when user logs in or starts a process.
- Examples (UNIX/Linux): Bourne-Again shell (bash), C shell, Korn shell.
- Choice of shell = user preference.

Main Function
-------------
- Read and execute user commands.
- Common tasks: create, delete, copy, list, execute files.

Implementation Approaches
-------------------------
1. Built-in Commands:
   * Interpreter contains code to directly execute commands.
   * Interpreter size grows with number of commands.

2. System Programs (UNIX style):
   * Interpreter invokes external program files (e.g., `rm file.txt` → runs program `rm`).
   * Easy to add new commands by creating new programs.
   * Interpreter remains small and flexible.


Graphical User Interface (GUI)
------------------------------
- User interacts with OS via windows, menus, icons (desktop metaphor).
- Mouse used to point, click, select, or open programs/files/folders.
- Origin:
  * First GUI → Xerox Alto (1973, Xerox PARC).
  * Popularized by Apple Macintosh (1980s).
  * Microsoft Windows (since 1.0) built on GUI over MS-DOS.
- Evolution:
  * macOS → Aqua interface.
  * Windows → enhanced appearance and functionality over versions.
- UNIX/Linux:
  * Traditionally CLI-based.
  * GUIs available → KDE, GNOME (open-source desktops).

Touch-Screen Interface
----------------------
- Common in mobile devices (smartphones, tablets).
- User interacts with gestures: tap, press, swipe.
- Replaces physical keyboards with on-screen keyboards.
- Examples:
  * iPhone & iPad → Springboard interface.
  * Earlier smartphones used physical keyboards (now mostly obsolete).


Choice of Interface
-------------------
- CLI vs GUI → mostly personal preference.
- Command-Line Interface (CLI):
  * Preferred by system administrators & power users.
  * More efficient for complex or repetitive tasks.
  * Supports scripting (shell scripts) for automation.
  * Common in UNIX/Linux systems.
- Graphical User Interface (GUI):
  * Preferred by most Windows and macOS users.
  * Easier for everyday tasks, visually intuitive.
  * Some functions may only exist in CLI, not GUI.
- Hybrid Examples:
  * Windows → GUI + optional touch screen.
  * macOS → Aqua GUI + CLI (UNIX-based).
- Mobile Systems:
  * Almost entirely touch-based (iOS, Android).
  * CLIs exist but rarely used.
- Key Note:
  * UI design is separate from OS internals.
  * OS focuses on providing services; UI is just one layer above.


System Calls
------------
- Interface between user programs and OS services.
- Usually provided as functions in C/C++; low-level tasks may use assembly.

Example: Copying One File to Another
------------------------------------
1. Acquire file names:
   * CLI: `cp in.txt out.txt`
   * Interactive: prompts + keyboard input
   * GUI: menus, icons, file selection
   → Requires I/O system calls

2. Open files:
   * Open input file → handle errors (file not found, access denied)
   * Create/open output file → handle conflicts (file exists, overwrite, abort, or ask user)

3. Copy loop:
   * Read from input file (system call)
   * Write to output file (system call)
   * Handle errors (EOF, disk errors, no space, device issues)

4. Finish:
   * Close files (system calls)
   * Display completion message (system call)
   * Terminate program normally (system call)

Key Idea
--------
- Even simple tasks (like copying a file) involve **many system calls**:
  * File operations, I/O, error handling, process termination.
- System calls provide controlled, safe access to OS resources.



Application Programming Interface (API)
---------------------------------------
- Provides a set of functions for application programmers to access OS services.
- Hides low-level system-call details from programmers.
- Common APIs:
  * Windows API → Windows systems
  * POSIX API → UNIX, Linux, macOS
  * Java API → Java Virtual Machine

How API Works
-------------
- Programmer calls API function (e.g., read(), CreateProcess()).
- API function invokes the appropriate system call internally.
- OS executes the system call in kernel mode, returns result to program.
- Programmer only needs to follow API; OS implementation details are hidden.
- Run-Time Environment (RTE) manages API, libraries, loaders, and compilers.

Example: read() in UNIX/Linux
------------------------------
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count)
- Parameters:
  * fd → file descriptor
  * buf → memory buffer
  * count → max bytes to read
- Returns number of bytes read, 0 = EOF, -1 = error.

Parameter Passing Methods
-------------------------
1. Registers → simplest, fast.
2. Memory block/table → used when too many parameters.
3. Stack → push parameters, OS pops them.
- Linux: ≤5 parameters → registers, >5 → block in memory.


Types of System Calls:

Process Control System Calls
----------------------------
- Terminate program:
  * end() → normal termination
  * abort() → abnormal termination (may produce memory dump, error message, log file)
- Error levels indicate severity:
  * 0 → normal termination
  * Higher values → more severe errors
  * Used by command interpreter/programs to decide next actions
- Load and execute other programs:
  * load(), execute() → run another program
  * Control after execution:
    - Return to original program (requires saving memory image)
    - Run concurrently (multiprogramming)
  * create process() → system call to create new process

Process Attributes & Management System Calls
-------------------------------
- get process attributes() / set process attributes() → check/set priority, max execution time, etc.
- terminate process() → stop a created process if unnecessary or incorrect

Waiting & Synchronization System Calls
------------------------
- wait time() → wait for a specified time
- wait event() → wait for a specific event
- signal event() → signal that an event occurred
- acquire lock(), release lock() → lock shared data to ensure integrity when accessed by multiple processes

Examples
--------
1. Arduino (Single-tasking system):
   - Program ("sketch") uploaded via PC to flash memory
   - Bootloader loads sketch
   - Only one sketch runs at a time; new sketch replaces old
   - Input via hardware sensors, no UI

2. FreeBSD (Multitasking system):
   - Shell waits for user commands
   - fork() → create new process
   - exec() → load and execute program
   - Background execution:
     - Shell continues while program runs
     - Input via files or GUI
   - exit() → terminate process, return status code (0 = success, non-zero = error)


File Management System Calls
----------------------------
- Create and delete files:
  * create() → create new file with name and attributes
  * delete() → remove file
- Open and use files:
  * open() → open a file for access
  * read() / write() → read from or write to a file
  * reposition() → move file pointer (rewind, skip to end, etc.)
  * close() → close file when done
- Directory operations:
  * Same operations can apply to directories in a hierarchical file system
- File attributes:
  * get file attributes() → read attributes (name, type, protection, accounting info)
  * set file attributes() → modify attributes
  * Some systems provide move() and copy() or APIs to perform these operations
  * System programs callable by other programs may act as APIs

Device Management System Calls
------------------------------
- Resources (memory, disk drives, files, etc.) may be requested and released
  * request() → request exclusive access to a device
  * release() → release the device after use
- I/O operations:
  * read() / write() / reposition() → similar to file operations
- Some OS merge files and devices into a single file-device structure
  * I/O devices may be identified by special file names, directory placement, or attributes
- Design decisions can make files and devices appear similar to the user, even if system calls differ

Information Maintenance System Calls
------------------------------------
- Transfer info between user program and OS:
  * time() → return current time
  * date() → return current date
  * Other calls → return system info (OS version, free memory/disk space)
- Debugging support:
  * dump() → memory dump for debugging
  * strace (Linux) → list system calls executed
  * Single-step CPU mode → trap after each instruction for debugging
- Time profiling:
  * Records program counter at timer interrupts
  * Generates statistical picture of time spent in program sections
- Process information:
  * get process attributes() / set process attributes() → access or modify process details



Communication System Calls
--------------------------
- Two models of interprocess communication (IPC):
  1. Message-passing model
  2. Shared-memory model

Message-Passing Model:
- Processes exchange messages directly or via a common mailbox
- Connection setup required:
  * get hostid() → translate host name to identifier
  * get processid() → translate process name to identifier
  * open connection() / close connection() → start and end communication
  * accept connection() → recipient permits communication
- Client-server model:
  * Client → source of communication
  * Server → receiving daemon, executes wait for connection()
  * read message() / write message() → exchange data

Shared-Memory Model:
- Processes create and attach to shared memory:
  * shared memory create() → create shared memory region
  * shared memory attach() → access memory region of another process
- Shared memory allows direct reading/writing between processes
- Processes responsible for avoiding conflicts
- Threads (Chapter 4) share memory by default

Comparison:
- Message passing → easier for intercomputer communication, handles small data
- Shared memory → fastest for same-computer communication, requires synchronization and protection

Protection System Calls
-----------------------
- Control access to resources (files, disks, etc.)
- set permission() / get permission() → set or query resource permissions
- allow user() / deny user() → grant or revoke user access
- Protection ensures safe resource access in multiprogramming and networked environments
- Security (external threats) discussed in Chapter 16



System Services
---------------

- Definition:
  * Also called system utilities
  * Provide environment for program development and execution
  * Some are simple interfaces to system calls; others are complex

- Categories of System Services:

1. File Management:
   - Create, delete, copy, rename, print, list files and directories
   - Access and manipulate file content and structure

2. Status Information:
   - Query system for date, time, memory, disk space, number of users
   - Provide performance, logging, debugging info
   - Output may be printed, displayed in GUI, or stored in registry

3. File Modification:
   - Text editors to create/modify file content
   - Commands to search, transform text

4. Programming-Language Support:
   - Compilers, assemblers, debuggers, interpreters (C, C++, Java, Python)
   - Provided with OS or as separate downloads

5. Program Loading and Execution:
   - Loaders: absolute, relocatable, linkage, overlay loaders
   - Debugging systems for high-level or machine language

6. Communications:
   - Enable virtual connections between processes, users, and systems
   - Functions: messaging, web browsing, email, remote login, file transfer

7. Background Services:
   - System programs launched at boot time
   - Some terminate after task; others run continuously (services, subsystems, daemons)
   - Examples: network daemon, process schedulers, error monitoring, print servers
   - OS may run activities in user context via daemons

- Applications:
  * Supplied OS programs for common tasks: web browsers, word processors, spreadsheets, databases, compilers, plotting/statistics, games

- User View:
  * User interacts with system via application and system programs, not direct system calls
  * Same hardware can present multiple interfaces (GUI, shell, dual-boot OS)
  * System calls remain consistent, interfaces differ


Linkers and Loaders
-------------------

- Purpose:
  * Bring program from disk into memory
  * Place program in context of a process to run on CPU

- Steps to Run a Program:
  1. Compilation:
     - Source files (.c, .cpp, etc.) → object files (.o)
     - Relocatable object file → can be loaded at any memory address
  2. Linking:
     - Combines object files into single executable
     - Can include libraries (e.g., standard C/math library using -lm)
     - Relocation performed → final addresses assigned, code/data adjusted
  3. Loading:
     - Loader places executable into memory
     - Program becomes eligible to run on CPU
     - On UNIX: shell uses fork() → creates process, exec() → invokes loader
     - On GUI: double-click icon triggers loader similarly

- Dynamic Linking:
  * Libraries may be dynamically linked during program load
  * Example: DLLs in Windows, conditional loading of math library
  * Benefits: avoids loading unused libraries, multiple processes can share libraries → memory savings

- File Formats:
  * Contain compiled code + symbol table (metadata for functions/variables)
  * UNIX/Linux → ELF (Executable and Linkable Format)
    - Separate formats for relocatable (.o) and executable files
    - Executable files contain entry point → address of first instruction
  * Windows → PE (Portable Executable)
  * macOS → Mach-O

- ELF Utilities:
  * file main.o → reports relocatable ELF object
  * file main → reports ELF executable
  * readelf → examine sections and details of ELF files




Why Applications Are OS Specific
--------------------------------
- User View:
  * Applications compiled on one OS usually cannot run on another OS
  * Running same application on multiple OSs requires:
    1. Interpreted languages (Python, Ruby) – interpreter executes source line by 
    line on native CPU, calls native system calls, limited performance and OS features
    2. Virtual Machine languages (Java) – RTE includes loader, bytecode verifier, VM; 
    allows app to run across OSs with RTE, similar performance limits as interpreters
    3. Standard language/APIs – compiler generates OS- and machine-specific binaries; 
    requires porting and testing for each OS (e.g., POSIX API for UNIX variants)

- System-Level Reasons:
  * Each OS has unique system calls differing in:
    - Numbering, operands, invocation method, behavior, and return values
  * OS provides libraries with APIs (e.g., GUI functions) – apps calling one OS's APIs may fail on another
  * Different binary formats for executables dictate layout of headers, instructions, and variables
  * CPUs have varying instruction sets; binaries must match CPU architecture
  * Application Binary Interface (ABI) specifies low-level binary compatibility per OS and CPU:
    - Address width, parameter passing, stack organization, system library format, data type sizes
  * ELF format in UNIX/Linux standardizes binary layout across UNIX systems but not across CPU architectures
  * Without interpreter, RTE, or OS-specific binary, applications fail on other OSs
  * Cross-platform apps (like Firefox) require separate builds and testing for each OS and CPU




Operating-System Design and Implementation
-------------------------------------------
- User View:
  * OS design depends on hardware type and system type: desktop/laptop, mobile, distributed, real-time
  * Users want convenience, ease of learning, reliability, safety, and speed
  * Developers want system to be easy to design, implement, maintain; also flexible, reliable, error-free, and efficient
  * No unique solution; different requirements yield different OS designs (e.g., VxWorks vs Windows Server)

- Mechanisms and Policies:
  * Mechanism = how something is done; Policy = what is done
  * Separation allows flexibility; policies can change without altering mechanisms
  * Example: Timer mechanism ensures CPU protection; setting timer length is policy
  * Priority mechanism can support multiple policies (I/O vs CPU intensive programs)
  * Microkernel OS: minimal mechanisms, policy implemented via modules or user programs
  * Windows/macOS: mechanism and policy tightly integrated for consistent interface
  * Open-source OS (Linux): mechanism defined, policy can be changed by modifying components (e.g., CPU scheduler)
  * Resource allocation decisions: 'what' → policy; 'how' → mechanism






Implementation of Operating Systems
-----------------------------------
- User View:
  * Once designed, an OS must be implemented as a collection of programs
  * Early OSs: written entirely in assembly language
  * Modern OSs: mostly written in higher-level languages (C, C++, Java), with small assembly portions
  * Example: Android
    - Kernel: mostly C + some assembly
    - System libraries: C or C++
    - Application frameworks: mostly Java

- Advantages of higher-level languages:
  * Faster development, more compact code, easier to understand and debug
  * Compiler improvements benefit entire OS
  * Easier to port to different hardware (embedded devices, x86, ARM)
  * Modern compilers produce optimized code, sometimes better than hand-written assembly for large programs

- Disadvantages:
  * Slightly reduced speed and increased storage needs (minor on modern systems)

- Performance considerations:
  * Major improvements come from better algorithms and data structures, not assembly coding
  * Only a small part of OS is performance-critical: interrupt handlers, I/O manager, memory manager, CPU scheduler
  * Critical routines can be optimized after system works correctly



Monolithic Structure
-------------------
- User View:
  * OS functionality combined into a single, static binary running in one address space
  * Simplest OS organization, minimal internal structure
  * Example: Original UNIX
    - Two main parts: kernel and system programs
    - Kernel provides file system, CPU scheduling, memory management, device drivers
    - Layered approach: everything below system-call interface and above hardware is kernel

- Linux Example:
  * Based on UNIX; monolithic kernel running entirely in kernel mode
  * Applications communicate with kernel via glibc C library and system-call interface
  * Kernel has modular features allowing runtime modification (dynamic modules)

- Advantages:
  * High performance: minimal system-call overhead
  * Fast internal kernel communication

- Disadvantages:
  * Difficult to implement, maintain, and extend
  * All functionality in a single address space increases complexity

- Usage:
  * Still common in UNIX, Linux, and Windows due to efficiency and speed




Layered Approach
----------------
- User View:
  * OS divided into separate layers, each with specific functionality
  * Bottom layer (layer 0) = hardware; top layer (layer N) = user interface
  * Each layer uses only the operations of lower-level layers, hiding internal implementation from higher layers

- Advantages:
  * Simplicity in construction, debugging, and verification
    - Debug one layer at a time; errors must be in the current layer
  * Encapsulation: higher layers don’t need to know details of lower layers
  * Supports modularity and easier system modification

- Implementation Notes:
  * Each layer = data structures + functions invoked by higher layers
  * Each layer invokes operations on lower layers only

- Disadvantages:
  * Difficult to define precise functionality for each layer
  * Performance overhead: user program may traverse multiple layers for services
  * Few OSs use pure layered approach; contemporary systems often have fewer layers with more functionality




Microkernels and Modules
------------------------
- Microkernels:
  * OS structure where only essential services remain in kernel; other services run in user space
  * Typical microkernel services: minimal process management, memory management, communication
  * Client programs and services communicate via message passing through the microkernel
  * Advantages:
    - Easier to extend OS: add new services in user space without changing kernel
    - Smaller kernel → easier to port to different hardware
    - Increased security and reliability: service failure doesn’t crash OS
  * Examples:
    - Darwin (macOS/iOS): uses Mach microkernel
    - QNX Neutrino: real-time OS with microkernel for message passing, process scheduling
  * Disadvantages:
    - Performance overhead from message passing and process switching
    - Example: early Windows NT microkernel slower than Windows 95; later versions moved closer 
      to monolithic for performance

Modules
------------------------


- Modules (Loadable Kernel Modules - LKMs):
  * Kernel has core components; additional services linked via modules at boot or runtime
  * Core services (e.g., CPU scheduling, memory management) in kernel; 
  other services (e.g., file systems, device drivers) loaded dynamically
  * Advantages:
    - Flexible and modular while maintaining performance
    - Modules can communicate without message passing
    - Dynamic loading allows runtime addition/removal (e.g., USB drivers)
  * Examples:
    - Linux, macOS, Solaris, Windows use LKMs
    - Linux LKMs support device drivers and file systems
